# 学習メモ

## 📋 目次

### Git & バージョン管理
- [gitとgithub](#gitとgithub) - 2025年8月16日
- [GitflowとGitHub Flow](#gitflowとgithub-flow) - 2025年8月16日
- [バージョン管理表記法ガイド](#バージョン管理表記法ガイド) - 2025年8月6日
- [git tag 活用ガイド](#git-tag-活用ガイド) - 2025年8月6日
- [git stash](#git-stash) - 2025年7月20日

### OS & インフラ
- [カーネルとOSの関係まとめ](#カーネルとosの関係まとめ) - 2025年8月16日

### Web開発
- [環境変数とenvファイル](#環境変数) - 2025年8月16日
- [YAML Front Matter](#yaml-front-matter) - 2025年7月21日
- [Bootstrap](#bootstrap) - 2025年7月16日

### その他
- [Markdownリンク作成ルール](#markdownリンク作成ルール) - 2025年7月17日
- [Whisper](#whisper) - 2025年7月2日

---

# 環境変数とenvファイル
**作成日**: 2025年8月16日

```
◎環境変数とは？
・プログラムの動作環境を切り替えたり、設定したりできる変数
・ローカル（開発用）とリモート（本番用）など、「環境ごとに変えたい設定」を柔軟に切り替えるための仕組み

◎具体的に切り替える例：
・APIのURL：ローカル（http://localhost:3000）⇔ 本番（https://api.example.com）
・DB接続先：ローカル（localhost:5432）⇔ 本番（db.production.com）
・機密キー（API_KEY）：開発（dev123）⇔ 本番（prod456）

◎なぜ環境変数で設定するのか？
・コードに直接書くと本番専用になってローカル開発しにくい
・環境変数を使えば.envファイルを切り替えるだけで環境設定を柔軟に変更できる
・環境ごとの設定値は環境変数にし、.envというファイルにまとめる
・コードは環境変数だけを見る設計にしておくとラク＆安全

◎セキュリティ面でのメリット
・.envはGitで共有しない（.gitignoreに追加）
・APIキー・パスワードなどの秘密情報をコードに書かずにすむ

◎一言でまとめると：
環境変数は「ローカル／リモートの設定切り替えをコード外から行うための変数」
.envファイルは「その設定をまとめておけるファイル」
```

**参考文献**: Next.js公式ドキュメント、Supabase公式ドキュメント

---

## .envファイル例（ローカル開発用）

```env
# .env
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
NEXT_PUBLIC_API_URL=http://localhost:3000
```

- `NEXT_PUBLIC_` をつけると、Next.jsのフロント側からも参照できる

---

## Supabase連携例：`lib/supabase.js`

```javascript
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

export const supabase = createClient(supabaseUrl, supabaseKey);
```

---

## APIで使う例：`pages/api/hello.js`

```javascript
export default function handler(req, res) {
  const apiUrl = process.env.NEXT_PUBLIC_API_URL;
  res.status(200).json({ message: `API URL is ${apiUrl}` });
}
```

---

## Vercelへの環境変数設定手順

```
Vercel管理画面 > Project Settings > Environment Variables
```

| Key                           | Value                                  |
|------------------------------|----------------------------------------|
| NEXT_PUBLIC_SUPABASE_URL     | https://your-project.supabase.co       |
| NEXT_PUBLIC_SUPABASE_ANON_KEY| your-anon-key                          |
| NEXT_PUBLIC_API_URL          | https://yourdomain.vercel.app/api      |

---

## .gitignoreに追加すべき設定

```gitignore
# Gitに含めないようにする
.env
```

---

# ネットワーク基礎
**作成日**: 2025年8月16日

```
◎ネットワークの基本概念
・TCP/IP：インターネットの標準プロトコル
・DNS：ドメイン名をIPアドレスに変換するシステム
・HTTP/HTTPS：Web通信のプロトコル

◎基本情報技術者試験での重要ポイント
・ネットワーク層の役割と機能
・IPアドレスの種類と範囲
・ルーティングとパケット転送
・セキュリティ（ファイアウォール、VPN等）

◎実務での活用
・Web開発でのネットワーク知識の重要性
・API通信の仕組み理解
・セキュリティ対策の基礎知識
```

**参考文献**: 基本情報技術者試験対策教材

---

# gitとgithub
**作成日**: 2025年8月16日

```
.gitはバージョン管理システム
・Linux開発を行う際のバージョン管理としてリナックス開発者が開発した

◎バージョン管理システムの歴史
・ローカル、集中、分散
集中はサーバー一つで管理、作業するときはネットが必要。
→Googleドライブみたいな作業体系
分散はそれぞれがコピー。ローカル作業、同期が可能
→gitはこれ！

◎gitの形態
・スナップショットとして保存(ファイル丸ごと保存)
・全てのコミットにハッシュ値(ハッシュ関数: どんなデータでも、一定のルールで「ハッシュ値（指紋）」に変換する関数（仕組み）　が作られ、そこで内容や履歴等まで管理)
 Gitは、全てのコミットを「ハッシュ関数で指紋化」して、データの中身をひとめでわかるようにし履歴をガッチリ追えるようにしてるだから速くて安全で信頼されてる。
・ブランチ、マージという概念
・リモートリポジトリ：一つのリポジトリに対して複数設定できる、pcは通常メインリモートをoriginって呼んでる
 1つのプロジェクトから、いろんな場所に「push」できるようにしておけるってこと。バックアップ用や、他人のリポジトリにもok


◎gitの機能
・リモート→ローカル：clone
・ローカル→リモート：push
・リモート変更→ローカル：pull

※プルリクエスト：ブランチのマージ(ソースコード変更の反映)を開発者に依頼。git自体には存在せず、githubのみの機能

・クローン: ＝ 「自分のGitHub上のリポジトリを、自分のPCにクローンする」
・フォーク: 他人のリポジトリを、自分のGitHubアカウントに「まるごとコピー」すること
```

**参考文献**: 図解git&githubのツボとコツが絶対にわかる本

---

# GitflowとGitHub Flow
**作成日**: 2025年8月16日

```
◎Gitflow：リリースされたコードの管理に適したGitのブランチ運用ルール
  → バージョン管理やリリース管理に強い
  ・使うブランチ：main, develop, feature, release, hotfix
  ・例：feature/機能名 に分けて複数人で開発 → developに統合 → releaseで調整 → mainへ

◎GitHub Flow：開発と運用どちらにも使える軽量な運用スタイル
  → 都度ブランチ作ってPR → GitHub上で議論・レビュー → mainにマージで即反映
  ・常にmainはデプロイ可能な状態が前提
```

---

# カーネルとOSの関係まとめ
**作成日**: 2025年8月16日


  ##  そもそもカーネルって何？

  - カーネル：OSの「心臓・頭脳」にあたる部分。
  - 役割：アプリとハードウェアの橋渡しをする超重要パーツ。

  例：アプリ「保存したい！」→ カーネル「OK！ディスクに命令出すね」

  ##  OS（オペレーティングシステム）とは？

  - PCやスマホを動かすための基本ソフト。
  - カーネルを中心に、UIやアプリ管理なども含まれる。

  ##  カーネルとOSの関係図（ざっくり）

  [ アプリ・サービス（LINE・Chromeなど） ]
                 ↓
           [ OS（macOS / Androidなど） ]
                 ↓
          [ カーネル（XNU / Linuxなど） ]
                 ↓
           [ ハードウェア（CPU・メモリなど） ]

  ##  Apple系（macOS / iOS）

  | OS名   | カーネル | 備考 |
  |--------|----------|------|
  | macOS  | XNU      | Mac用。UNIX系。 |
  | iOS    | XNU      | iPhone用。macOSを軽量化して最適化したもの。 |

  ‍‍ → **兄妹のような関係**。中身は似てるけど用途が違う。

  ##  AndroidとLinux

  | OS名     | カーネル       | 備考 |
  |----------|----------------|------|
  | Linux    | Linuxカーネル   | PC・サーバー用のOS（Ubuntuなど） |
  | Android  | Linuxカーネル（改造版） | スマホ用に最適化されたOS |

   → **カーネルは同じ、でも用途も見た目も別物**。

  ##  比較まとめ表

  | 項目       | macOS / iOS   | Linux / Android |
  |------------|----------------|------------------|
  | カーネル   | XNU           | Linuxカーネル    |
  | 開発元     | Apple         | Linuxはコミュニティ / AndroidはGoogle |
  | 使われ方   | Mac, iPhone   | サーバー, PC, Androidスマホ |
  | ソース形態 | クローズド    | オープンソース   |
  | 関係性     | 兄妹関係       | 遠い親戚関係      |

  ## ✅ ざっくりまとめ一言

  - **カーネルはOSのエンジン部分！**
  - **macOSとiOSは同じApple製の兄妹OS！**
  - **AndroidとLinuxは同じLinuxカーネルを持つ別のシステム！**

<br><br><br>
---

# バージョン管理表記法ガイド
**作成日**: 2025年8月6日

---

##  概要
バージョン管理における表記法は、ソフトウェアやプロジェクトの変更履歴を追跡し、開発者や利用者に変更内容の重大性を伝えるための共通言語。特に
  **セマンティックバージョニング（Semantic Versioning）**は、互換性の有無を明確にするためのデファクトスタンダードとして広く採用されている。

---

##  セマンティックバージョニング (SemVer)

ソフトウェアのバージョン番号を `MAJOR.MINOR.PATCH` の3つの数字で管理する規約。

- **`MAJOR` (メジャー)**: **互換性のない**APIの変更があった場合にインクリメント（+1）する。
- **`MINOR` (マイナー)**: **後方互換性のある**機能追加があった場合にインクリメントする。
- **`PATCH` (パッチ)**: **後方互換性のある**バグ修正があった場合にインクリメントする。

### なぜSemVerを使うのか？
- **依存関係の管理**: `package.json`などで「`~1.0.4`」（パッチバージョンまで許容）や「`^1.0.4`
  」（マイナーバージョンまで許容）といった柔軟な依存関係を指定でき、安全なアップデートが可能になる。
- **変更の意図の明確化**: バージョン番号を見るだけで、アップデートに伴うリスク（破壊的変更の有無）を判断できる。
- **コミュニケーションコストの削減**: 開発者と利用者の間で、変更内容に関する認識齟齬が生まれにくくなる。

---

##  実装例（SemVerのライフサイクル）

   1. 最初の公開リリース
     v1.0.0

   2. 後方互換性のあるバグを修正
     v1.0.1

   3. 後方互換性のある新機能を追加
     v1.1.0


   4. 既存の機能を変更し、後方互換性がなくなった（破壊的変更）
     v2.0.0


---

##  拡張表記：プレリリースとビルドメタデータ

### プレリリースバージョン
正式リリース前の、不安定なバージョンを示すために使用する。`PATCH`バージョンの直後にハイフン`-`と識別子を付ける。

- **アルファ版**: `1.0.0-alpha.1` (新機能の初期テスト段階)
- **ベータ版**: `1.0.0-beta.1` (機能は揃っているが、まだバグがある可能性)
- **リリース候補版**: `1.0.0-rc.1` (リリースに近いが、最終確認が必要)

### ビルドメタデータ
バージョン管理上は重要でない、ビルド日時やコミットハッシュなどの追加情報。バージョンの直後にプラス`+`と識別子を付ける。

- **例**: `v1.0.0+202508061030`
- **注意**: ビルドメタデータはバージョンの優先順位には影響しない。（例: `1.0.0`と`1.0.0+build123`は同じバージョンと見なされる）

---

##  その他のバージョン表記法

### カレンダーバージョニング (CalVer)
日付をベースにしたバージョン管理。OSやWebサービスなど、定期的にリリースされるプロジェクトで採用される。

- **フォーマット例**:
  - `YYYY.MM.PATCH` (例: `2025.08.1`)
  - `YY.MM` (例: Ubuntu `24.04`)
- **メリット**: リリースの時期が直感的にわかる。

### プロジェクト名・コードネーム
OSや大規模なソフトウェアで、マーケティング的な目的で使われる。

- **例**:
  - `Windows 11`
  - `macOS Sonoma`
  - `Android 14`

---
<br><br><br>
# git tag 活用ガイド
**作成日**: 2025年8月6日

---

##  概要
`git tag`は、Gitリポジトリの歴史における**特定のコミット（バージョン）に永続的な名前を付ける**ためのコマンド。ソフトウェアのリリースポイント（例:
  `v1.0`）や、プロジェクトの重要なマイルストーン（例: `spec-defined`
  ）を記録するために使用される。これにより、後から特定のバージョンを簡単に見つけ出し、参照・復元することが可能になる。

---

##  `git tag`採用のメリット

### バージョン管理
- **リリースポイント**: `v1.0.0`のようにセマンティックバージョニングに基づいたタグを付け、製品のリリースを明確に管理。
- **修正パッチ**: `v1.0.1`のように、特定のバグ修正やマイナーアップデートのバージョンを記録。
- **再現性**: いつでも特定のリリースバージョンのソースコードを正確に再現できる。

### プロジェクト管理
- **マイルストーン**: 「仕様策定完了」「デザインFIX」など、開発プロセスの重要な到達点にタグ付け。
- **コードフリーズ**: リリース前のコードフリーズ時点など、特定の状態を保存。
- **可読性**: `a1b2c3d`のようなコミットハッシュの代わりに、人間が理解できる名前でバージョンを管理できる。

### CI/CD連携
- **自動デプロイ**: 特定のフォーマット（例: `v*.*.*`）のタグがpushされたことをトリガーに、本番環境への自動デプロイを実行。
- **リリースノート自動生成**: タグが作成された際に、それまでのコミットログを元にリリースノートを自動で生成。

---

##  実装例（基本コマンド）

  --- タグの作成 ---

  軽量タグ（シンプルに名前を付けるだけ）
  git tag v1.0.0


  注釈付きタグ（推奨: 作成者、日付、メッセージを含められる）
  git tag -a v1.0.1 -m "バグ修正とパフォーマンス改善"

  --- タグの操作 ---

  タグの一覧を表示
  git tag

  特定のタグの詳細情報を表示（注釈付きの場合）
  git show v1.0.1

  --- リモートリポジトリとの連携 ---


  特定のタグをリモートに送信
  git push origin v1.0.1

  全てのローカルタグを一度にリモートに送信
  git push origin --tags


---

##  ワークフローでの活用
**リリースフローの自動化**:
- `main`ブランチでリリース準備が完了したら、`git tag -a vX.X.X`でバージョンタグを付ける。
- GitHub ActionsなどのCI/CDツールがタグのpushを検知し、ビルド、テスト、デプロイを自動実行。

**ホットフィックス**:
- 本番で緊急のバグが発生した場合、該当するリリースタグ（例: `v1.2.0`）から`hotfix`ブランチを作成。
- 修正後、`main`にマージし、新しいパッチバージョンのタグ（`v1.2.1`）を付けてリリース。

---

##  今後の拡張可能性
- **署名付きタグ**: GPGキーで署名されたタグ（`git tag -s`）を利用し、リリースの信頼性とセキュリティを向上させる。
- **タグ付けの自動化**: コミットメッセージの規約（Conventional Commitsなど）を使い、セマンティックバージョニングに基づいたタグ付けを自動化する。
- **変更履歴との連携**: タグ作成時に、CHANGELOG（変更履歴ファイル）を自動で更新するスクリプトを導入する。

---

## ✅ まとめ
---
<br><br><br>
# YAML Front Matter
**作成日**: 2025年7月21日

---

## 📝 概要
YAML Front Matterは、MarkdownファイルやHTML生成システムで使われる**メタデータ管理手法**。ファイルの先頭に`---`で囲まれたYAML形式でページ情報を定義し、SEO最適化、ブログ連携、サイト管理の効率化を実現する。実践型IT用語辞典では、各用語ページの品質向上と運用効率化のために採用。

---

## 🎯 YAML Front Matter採用のメリット

### SEO効果
- **title**: ページタイトルの最適化
- **description**: メタディスクリプション設定（160文字以内）
- **keywords**: SEOキーワード指定による検索順位向上
- **canonical**: 正規URL設定で重複コンテンツ回避

### ブログ連携
- **category**: カテゴリ分類による記事整理
- **tags**: タグ付けで関連記事の自動推薦
- **slug**: URL用スラッグでSEOフレンドリーなアドレス
- **featured_image**: アイキャッチ画像でSNS投稿時の見栄え向上

### サイト管理
- **difficulty**: 難易度レベル（初級・中級・上級）による学習フロー管理
- **reading_time**: 読了時間で学習計画をサポート
- **author**: 著者情報で責任の明確化
- **date**: 作成・更新日で情報の鮮度管理

---

## 💡 実装例（フールプルーフ）
```yaml
---
title: "フールプルーフ - 実践型IT用語辞典"
description: "利用者の操作ミスを防ぐ設計思想。誰が使っても安全な仕組みを目指す考え方を分かりやすく解説"
keywords: ["フールプルーフ", "UI/UX", "設計思想", "安全性", "エラー防止"]
category: "設計・UX"
tags: ["安全性", "UI設計", "エラー防止", "ユーザビリティ"]
difficulty: "初級"
reading_time: "5分"
author: "実践型IT用語辞典"
date: "2025-07-20"
slug: "foolproof"
canonical: "https://example.com/foolproof"
---
```

---

## 🔧 HTMLテンプレートでの活用
**変数置換による自動化**：
- `{{meta_title}}`: ページタイトル自動設定
- `{{meta_description}}`: メタディスクリプション自動生成
- `{{difficulty_badge}}`: 難易度バッジ表示
- `{{category}}`: カテゴリ分類表示

**構造化データ自動生成**：
JSON-LDを使ったリッチスニペット対応で検索結果での表示改善

---

## 📊 今後の拡張可能性
- **自動化機能**: カテゴリ別一覧ページの自動生成
- **分析機能**: 難易度別学習フローの提案
- **関連記事システム**: タグベースの自動推薦
- **RSS配信強化**: メタデータを活用した充実した配信

---

## ✅ まとめ
YAML Front Matterの採用により、SEO効果とサイト管理効率を大幅に向上。単なるメタデータ管理を超え、学習者にとって使いやすく、運営にとって管理しやすい辞典サイトの基盤技術として活用できる。

---
<br><br><br>
# git stash
**作成日**: 2025年7月20日

---

## 📝 概要
`git stash`